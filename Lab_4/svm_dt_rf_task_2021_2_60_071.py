# -*- coding: utf-8 -*-
"""SVM_DT_RF_TASK_2021-2-60-071.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/14n2LjqrXF-1K73TgZXH-c6yWH8jk4THO

#Dataset description

This dataset records detailed information about ticket sales and customer behavior at a cinema hall, offering insights into various aspects such as demographics, movie genre preferences, seat selection, ticket pricing, and customer retention patterns. It is designed to help analyze customer engagement, spending behavior, and factors that influence repeat visits to the cinema. The data is useful for predictive modeling and can support decision-making processes related to customer retention, marketing strategies, and optimizing cinema operations.

Columns Overview:

**Ticket_ID (Categorical):**

Description: A unique alphanumeric identifier for each ticket purchase. The ID consists of a random uppercase letter (A-Z) followed by a 4-digit number (e.g., B7539, Y1344).
Significance: This column helps identify each individual transaction. It's a categorical variable, essential for tracking specific customer purchases but not related to other variables directly.

**Age (Numerical):**

Description: The age of the customer who purchased the ticket, ranging between 18 and 60 years.
Significance: Age is an important demographic feature, providing insights into customer segments. For example, younger audiences might prefer different movie genres or seating types compared to older customers. Analyzing age data can help cinema halls cater to the needs of various age groups.

**Ticket_Price (Numerical):**

Description: The price the customer paid for the ticket, typically ranging from $10 to $25. The price varies based on factors like movie time, seat type, or cinema location.
Significance: Ticket price reflects customer spending and the cinema's pricing strategy. Understanding how ticket pricing impacts customer behavior can help optimize ticket sales and maximize revenue.

**Movie_Genre (Categorical):**

Description: The genre of the movie the customer attended, which can include one of the following: Action, Comedy, Horror, Drama, or Sci-Fi.
Significance: Genre preferences are crucial for understanding customer interests. Analyzing which genres are most popular can guide movie scheduling, marketing strategies, and even help in curating personalized recommendations for customers.

**Seat_Type (Ordinal):**

Description: The type of seat selected by the customer, with three ordinal categories:
Standard (Basic seating option)
Premium (Enhanced seating with added comfort)
VIP (Exclusive seating, offering premium features like extra legroom and priority service)
Significance: Seat type provides insights into customer spending behavior. Premium and VIP seat types typically correlate with higher ticket prices, and understanding seat preferences can help in optimizing cinema layout and pricing strategies. Additionally, this column can be used to gauge the popularity of high-end seating options.

**Number_of_Person (Mixed Variable):**

Description: The number of people accompanying the customer. This can either be:
Alone: The customer attended alone.
2â€“7: The customer attended with a group of 2 to 7 people.
Significance: Group size is an important factor in understanding customer preferences and behavior. For example, groups might purchase more tickets or opt for different movie genres and seat types than solo attendees. This column is crucial for analyzing social dynamics and group behavior in cinema attendance.

**Purchase_Again (Target - Binary):**

Description: A binary target variable indicating whether the customer is likely to return and purchase another ticket. It has two possible values:
Yes: The customer is likely to return for another movie.
No: The customer is not likely to return.
Significance: This is the key column for predictive modeling. It is used to assess customer retention and predict the likelihood of future ticket purchases. Analyzing the factors that influence repeat purchases (e.g., age, genre preferences, seat types) helps cinema halls optimize marketing and customer engagement strategies.
"""

from google.colab import drive
drive.mount('/content/drive')

"""#Task

1. Rename this notebook with your id
2. Load given dataset
3. Display dataset information and clean the data (print first 15 rows, show all column name, check for null, handle null values, show all unique values for non numeric column)
4. Map the non numeric colum using dictionary. Note, your target column is "Purchase_Again".

5. Apply Machine learning algorithms (SVM, DT and RF) and display their accuracy, precision, recall, confusin matrix. Note, you MUST write your findings after each code blocks. This is where you discuss regarding the reuslt you received.

6. Make a comparison table with all the results from different ML Algos.

7. Apply "grid search" to improve the achieved results for SVM, DT and random forest. Hint: you need to find what are the parameters to be tuned and what is their expected range. Accordingly, set 'grid search' parameters.

8. Suggest and use anyother parameter tuning technique that is more suitable that grid search for any of these ML Alogs. Justify your choice.

9. Finally, report the best models that you created. Justify why it is best. Carefully report required performance measures. Hints: Different performance measures may be selected for balanced vs unbalanced dataset.
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from sklearn.metrics import confusion_matrix, ConfusionMatrixDisplay
from sklearn.model_selection import train_test_split
from sklearn.ensemble import RandomForestClassifier
from sklearn.svm import SVC
from sklearn.tree import DecisionTreeClassifier
from sklearn.model_selection import RandomizedSearchCV
from sklearn import tree
from sklearn.model_selection import GridSearchCV
from sklearn.metrics import accuracy_score, precision_score, recall_score, f1_score

# Function
def performance_analysis(model, X_test, y_test):
    y_pred = model.predict(X_test)
    acc = accuracy_score(y_test, y_pred)
    prec = precision_score(y_test, y_pred)
    rec = recall_score(y_test, y_pred)
    f1 = f1_score(y_test, y_pred)

    print("Accuracy:", acc)
    print("Precision:", prec)
    print("Recall:", rec)
    print("F1-Score:", f1)
    print("\n")

    cm = confusion_matrix(y_test, y_pred)
    cm_display = ConfusionMatrixDisplay(confusion_matrix = cm, display_labels = ['Negative', 'Positive'])
    cm_display.plot()
    plt.title("Confusion Matrix")
    plt.show()
    return acc, prec, rec, f1

df = pd.read_csv('/content/drive/MyDrive/CSE475/Lab_04/cinema_hall_ticket_sales.csv')
df

df.head(15)

df.isnull().sum()

df.duplicated().sum()

df.info()

df['Movie_Genre'].unique()

df['Seat_Type'].unique()

df['Number_of_Person'].unique()

df['Purchase_Again'].unique()

mappings = {
    "Movie_Genre": {"Comedy": 1, "Drama": 2, "Horror": 3, "Action": 4, "Sci-Fi": 5},
    "Seat_Type": {"Standard": 1, "VIP": 2, "Premium": 3},
    "Number_of_Person": {"Alone": 1, "2": 2, "3": 3, "4": 4, "5": 5, "6": 6, "7": 7,},
    "Purchase_Again": {"No": 0, "Yes": 1}
}

df.replace(mappings, inplace=True)

df

df.drop(columns=['Ticket_ID'], inplace=True)

correlation = df.corr()
correlation

plt.figure(figsize=(12,8), dpi=77)
sns.heatmap(correlation, linecolor='white',linewidths=0.1, annot=True)
plt.title('Correlation Matrix'.upper(), size=19, pad=13)
plt.xlabel('Drivers License Data')
plt.ylabel('Drivers License Data')
plt.xticks(rotation=33)
plt.show()

X=df.drop(columns=['Purchase_Again'])
Y=df['Purchase_Again']

from sklearn.model_selection import train_test_split
X_train, X_test, y_train, y_test = train_test_split(X, Y, test_size=0.2, random_state=42)

"""# **SVM**"""

# Initialize the SVM model

svm = SVC(kernel='linear', random_state=42)

# Train the model
svm.fit(X_train, y_train)

svm_metrics = performance_analysis(svm, X_test, y_test)

"""# **Decision Tree**"""

dtree = DecisionTreeClassifier()
dtree = dtree.fit(X_train, y_train)

features = ['Age',
            'Ticket_Price',
            'Movie_Genre',
            'Seat_Type',
            'Number_of_Person',
            ]
tree.plot_tree(dtree, feature_names=features)

dtree_metrics = performance_analysis(dtree, X_test, y_test)

"""# **Random Forest**"""

rf = RandomForestClassifier(n_estimators=100, random_state=42)
rf.fit(X_train, y_train)

rf_metrics = performance_analysis(rf, X_test, y_test)

"""# **Comparison Table**"""

comparison = pd.DataFrame({
    'Model': ['SVM', 'Decision Tree', 'Random Forest'],
    'Accuracy': [svm_metrics[0], dtree_metrics[0], rf_metrics[0]],
    'Precision': [svm_metrics[1], dtree_metrics[1], rf_metrics[1]],
    'Recall': [svm_metrics[2],dtree_metrics[2],rf_metrics[2]],
    'F1 Score': [svm_metrics[3],dtree_metrics[3],rf_metrics[3]]
})

print(comparison)

"""# **Grid Search**

"""

# SVM
param_svm = {
    'C': [0.1, 1, 2, 10],
    'kernel': ['linear'],
    'gamma': ['scale', 'auto'],
    'random_state': [42]
}
grid_svm = GridSearchCV(SVC(), param_svm, cv=5, scoring='accuracy')
grid_svm.fit(X_train, y_train)
print("Best SVM Params:", grid_svm.best_params_)

grid_svm_metrics = performance_analysis(grid_svm, X_test, y_test)

# Decision Tree
param_dt = {
    'criterion': ['gini', 'entropy'],
    'max_depth': [5, 10, 20, None],
    'min_samples_split': [2, 5, 10],
    'min_samples_leaf': [1, 2, 4],
    'random_state': [42]
}
grid_dt = GridSearchCV(DecisionTreeClassifier(), param_dt, cv=5, scoring='accuracy')
grid_dt.fit(X_train, y_train)
print("Best DT Params:", grid_dt.best_params_)

grid_dt_metrics = performance_analysis(grid_dt, X_test, y_test)

# Random Forest
param_rf = {
    'n_estimators': [100, 150, 200],
    'criterion': ['gini', 'entropy'],
    'max_depth': [5, 10, None],
    'min_samples_split': [2, 5, 10],
    'min_samples_leaf': [1, 2, 3]
}
grid_rf = GridSearchCV(RandomForestClassifier(), param_rf, cv=5, scoring='accuracy')
grid_rf.fit(X_train, y_train)
print("Best RF Params:", grid_rf.best_params_)

grid_rf_metrics = performance_analysis(grid_rf, X_test, y_test)

"""# **Comparison**"""

comparison = pd.DataFrame({
    'Model': ['SVM', 'Decision Tree', 'Random Forest'],
    'Accuracy': [grid_svm_metrics[0], grid_dt_metrics[0], grid_rf_metrics[0]],
    'Precision': [grid_svm_metrics[1], grid_dt_metrics[1], grid_rf_metrics[1]],
    'Recall': [grid_svm_metrics[2],grid_dt_metrics[2],grid_rf_metrics[2]],
    'F1 Score': [grid_svm_metrics[3],grid_dt_metrics[3],grid_rf_metrics[3]]
})

print(comparison)

"""# **RandomizedSearch**"""

# SVM
random_svm = RandomizedSearchCV(SVC(), param_svm, n_iter=10, cv=5, scoring='accuracy', random_state=42)
random_svm.fit(X_train, y_train)
print("Random Search Best RF Params:", random_svm.best_params_)

random_svm = performance_analysis(random_svm, X_test, y_test)

# Decision Tree
random_dt = RandomizedSearchCV(DecisionTreeClassifier(), param_dt, n_iter=10, cv=5, scoring='accuracy', random_state=42)
random_dt.fit(X_train, y_train)
print("Random Search Best RF Params:", random_dt.best_params_)

random_dt = performance_analysis(random_dt, X_test, y_test)

# Random Forest
random_rf = RandomizedSearchCV(RandomForestClassifier(), param_rf, n_iter=10, cv=5, scoring='accuracy', random_state=42)
random_rf.fit(X_train, y_train)
print("Random Search Best RF Params:", random_rf.best_params_)

random_rf = performance_analysis(random_rf, X_test, y_test)

comparison = pd.DataFrame({
    'Model': ['SVM', 'Decision Tree', 'Random Forest'],
    'Accuracy': [random_svm[0], random_dt[0], random_rf[0]],
    'Precision': [random_svm[1], random_dt[1], random_rf[1]],
    'Recall': [random_svm[2],random_dt[2],random_rf[2]],
    'F1 Score': [random_svm[3],random_dt[3],random_rf[3]]
})

print(comparison)

"""# **Best Model**"""

rf = RandomForestClassifier(n_estimators= 150, min_samples_split= 2, min_samples_leaf= 1, max_depth= 10, criterion= "entropy", random_state=42)
rf.fit(X_train, y_train)

rf = performance_analysis(rf, X_test, y_test)